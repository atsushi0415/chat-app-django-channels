# 💬 リアルタイムチャットアプリケーション

> **Django Channels**と**WebSocket**を利用した、ユーザー認証・フレンド機能付きのリアルタイムコミュニケーションアプリ。

---

## 📋 目次

1.  [概要 (Overview)](#1-概要-overview)
2.  [機能一覧 (Features)](#2-機能一覧-features)
3.  [技術スタック (Tech Stack)](#3-技術スタック-tech-stack)
4.  [工夫点・アピールポイント (Highlights)](#4-工夫点アピールポイント-highlights)
5.  [動作確認 (Demo / Deploy)](#5-動作確認-demo--deploy)
6.  [ローカル環境でのセットアップ (Setup Guide)](#6-ローカル環境でのセットアップ-setup-guide)
7.  [今後の展望 (Future Plans)](#7-今後の展望-future-plans)

---

## 1. 概要 (Overview)

このプロジェクトは、即時性の高いコミュニケーションを実現するために開発されたチャットアプリケーションです。基本的なユーザー認証に加え、**フレンド機能**と**ルーム機能**（オープンチャットとプライベートチャット）を実装しました。

### 解決したい課題 (Objectives)

* **リアルタイム通信の仕組みを深く理解し、実際に動作するアプリケーションを通じてその技術を習得すること**を目標としました。特に、**WebSocket**を用いた双方向通信のライフサイクル（接続、切断、メッセージ送信）をサーバー側（**Django Channels**）とクライアント側（JavaScript）の両面から構築することに注力しました。
* **DjangoやSQLiteの仕組みを理解し習得するため**、特に**認証システム**（ログイン・新規登録）や、**Django ORM**を使った複雑なデータベースクエリ（フレンド検索、重複ルームの防止など）の実装を通して、フレームワークの機能とデータベース操作の基礎を固めました。

---

## 2. 機能一覧 (Features)

| カテゴリ | 機能詳細 |
| :--- | :--- |
| **ユーザー機能** | 新規登録、ログイン/ログアウト、マイページでの情報表示（自己紹介/趣味）、ユーザー情報変更 |
| **フレンド機能** | **フレンドコード**によるユーザー検索、フレンド申請・承認/拒否、フレンドリスト表示、フレンド削除 |
| **ルーム機能** | **オープンチャットルーム**の作成と参加、**フレンド専用チャットルーム**の作成と参加 |
| **チャット機能** | ルーム内でのリアルタイムメッセージ送受信（WebSocket）、接続中ユーザーリストのリアルタイム更新、メッセージのタイムスタンプ表示 |

---

## 3. 技術スタック (Tech Stack)

このプロジェクトは以下の技術スタックで構築されています。

| 分類 | 技術名 | バージョン | 選定理由・役割 |
| :--- | :--- | :--- | :--- |
| **バックエンド** | **Python** | 【3.x】 | 主力言語。可読性の高さと豊富なライブラリ。 |
| **Webフレームワーク**| **Django** | 【4.x】 | 堅牢なMVC/MTVアーキテクチャによる迅速な開発。ORMによるDB操作。 |
| **リアルタイム通信**| **Django Channels**| 【4.x】 | Django環境下でWebSocketを容易に実装するため。非同期処理の基盤。 |
| **データベース** | **SQLite** | - | 開発環境での手軽さ（本番環境ではPostgreSQLなどを想定） |
| **フロントエンド**| **HTML / CSS**| - | 画面構成とデザイン。CSSはFlexbox/Gridを使用。 |
| **開発環境** | **Git / GitHub** | - | バージョン管理、チーム開発を意識したコミット運用。 |

---

## 4. 工夫点・アピールポイント (Highlights)

### ① フレンド機能の独自設計と状態管理

* **工夫点**: フレンド機能の実装が初めてだったため、単にユーザーを紐づけるだけでなく、「**申請中**」と「**フレンド成立**」の**状態遷移**を適切に管理する必要性を考慮しました。
* **実装内容**:
    * `Friend`モデルに`request`フィールドを設け、「0: 申請中」「1: フレンド成立」として状態を定義しました。
    * マイページでは、`request=1`のフレンドリストと、`request=0`の**承認待ちリスト**を分けて表示することで、ユーザーが自身の状態を直感的に把握できるUI/DB設計を行いました。

### ② フレンドチャットの重複防止と複雑なORMクエリ（アピールポイント）

* **課題と解決**: ユーザーAとBのチャットルームを作成する際、ユーザーが再度BとAでルームを作ろうとした場合に、**同じフレンド間のルームが重複して作成されるのを防ぐ**必要がありました。
* **実装内容**: Django ORMの **`Q`オブジェクト** を利用し、ログインユーザーが **`user`または`friend`のどちらのフィールドにいても**、かつ、選択したフレンドが **`user`または`friend`のどちらのフィールドにいても**、すでにルームが存在するかを一度のクエリで判定する複雑なクエリ（`Q(user=A, friend=B) | Q(user=B, friend=A)`）を記述し、ビジネスロジックの正確性を担保しました。

### ③ リアルタイム通信の実現 (Django Channels)

* **実装内容**: `AsyncWebsocketConsumer` を使用し、ルームごとのグルーピング（`channel_layer.group_add`）を行うことで、特定のルームに参加しているユーザー間でのみメッセージがリアルタイムに共有される仕組みを構築しました。
    * 特に、クライアント側JavaScriptで**`data.timestamp`**を正確な日付形式に変換する処理を実装し、**`NaN`エラー**を回避するなど、細部にわたる安定性も意識しました。

### ④ ユーザー体験(UX)を意識したUI/JavaScript制御

* **実装内容**: 【chat\_room.html】では、チャットログのフォームを上部に配置し、ログ表示エリアに枠線と**最小高さを設定**することで、メッセージがない状態でもレイアウトが崩れないよう配慮しました。
* **JavaScript制御**: フレンド検索結果や申請ボタンの表示・非表示を、サーバーサイドのコンテキスト（`{{ found_user }}`や`{{ friend_request }}`）に応じてJavaScriptで動的に制御し、**不要な画面遷移を防ぐ**UXを追求しました。

---

## 5. 動作確認 (Demo / Deploy)

### 📸 画面イメージ
    * 例: ログイン画面


    * 例: チャットルームでのリアルタイム通信の様子 

---

## 6. ローカル環境でのセットアップ (Setup Guide)

**前提ソフトウェア**

* Python (3.8以上推奨)
* pip (Pythonパッケージインストーラ)
* Git

**手順**

1.  **リポジトリのクローン**
    ```bash
    git clone [https://github.com/atsushi0415/chat-app-django-channels](https://github.com/atsushi0415/chat-app-django-channels)
    cd chat-app-django-channels
    ```

2.  **仮想環境の構築と有効化**
    ```bash
    python -m venv venv
    source venv/bin/activate  # macOS/Linuxの場合
    # .\venv\Scripts\activate  # Windowsの場合
    ```

3.  **依存関係のインストール**
    ```bash
    pip install -r requirements.txt 
    # (または、pip install django djangochannels daphne ...)
    ```

4.  **データベースのマイグレーション**
    ```bash
    python manage.py migrate
    ```

5.  **スーパーユーザーの作成**
    ```bash
    python manage.py createsuperuser
    ```

6.  **アプリケーションの起動 (Daphne / Channelsを使用)**

    > 💡 **重要**: Django ChannelsによるWebSocketを正しく動作させるには、非同期をサポートするサーバー（Daphneなど）が必要です。`python manage.py runserver` ではなく、以下のコマンドで起動してください。
    ```bash
    # [myproject] の部分は、ご自身のプロジェクト名に合わせて修正してください
    daphne -b 0.0.0.0 -p 8000 [myproject].asgi:application
    ```

7.  ブラウザで [http://127.0.0.1:8000/](http://127.0.0.1:8000/) にアクセスし、新規ユーザー登録またはログインしてください。

8. **他のデバイスでログインする際**
    ブラウザで使用しているネットワークのIPアドレス+ポート番号にアクセス(例:XXX.XXX.X.X:8000)し、新規ユーザー登録またはログインしてください。。

---

## 7. 今後の展望 (Future Plans)

開発プロセスで時間やリソースが許せば、以下の機能を追加/改善したいと考えています。

* **メッセージの永続化**: 現在はメモリ上でのみメッセージを処理しているため、データベース（PostgreSQLなど）に保存し、ルーム参加時に過去ログを表示する機能を追加する。
* **オープンチャットからフレンドページへの遷移**: **UX改善**のため、オープンチャットの接続ユーザーリストから直接相手のマイページへ遷移し、その場でフレンド申請が行える機能を追加する。これにより、フレンドコードを手動でやり取りする手間をなくす。
* **セキュリティ強化**: CSRF対策、XSS対策の徹底、及びユーザーパスワードのハッシュ化（Django標準機能を使用済み）以外のセキュリティ対策も検討する。

---

**開発者情報**: 【あなたのGitHubアカウント名】
**最終更新日**: 【日付 2025-10-31】